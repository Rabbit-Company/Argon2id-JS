function runWorker() { class Blake2b { v = new Uint32Array(32); m = new Uint32Array(32); BLAKE2B_IV32 = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]); SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; parameterBlock = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); SIGMA82 = new Uint8Array(this.SIGMA8.map(function (t) { return 2 * t; })); ADD64AA(t, e, n) { let i = t[e] + t[n], r = t[e + 1] + t[n + 1]; i >= 4294967296 && r++, t[e] = i, t[e + 1] = r; } ADD64AC(t, e, n, i) { let r = t[e] + n; n < 0 && (r += 4294967296); let a = t[e + 1] + i; r >= 4294967296 && a++, t[e] = r, t[e + 1] = a; } B2B_GET32(t, e) { return t[e] ^ t[e + 1] << 8 ^ t[e + 2] << 16 ^ t[e + 3] << 24; } B2B_G(t, e, n, i, r, a) { let l = this.m[r], s = this.m[r + 1], o = this.m[a], h = this.m[a + 1]; this.ADD64AA(this.v, t, e), this.ADD64AC(this.v, t, l, s); let c = this.v[i] ^ this.v[t], g = this.v[i + 1] ^ this.v[t + 1]; this.v[i] = g, this.v[i + 1] = c, this.ADD64AA(this.v, n, i), c = this.v[e] ^ this.v[n], g = this.v[e + 1] ^ this.v[n + 1], this.v[e] = c >>> 24 ^ g << 8, this.v[e + 1] = g >>> 24 ^ c << 8, this.ADD64AA(this.v, t, e), this.ADD64AC(this.v, t, o, h), c = this.v[i] ^ this.v[t], g = this.v[i + 1] ^ this.v[t + 1], this.v[i] = c >>> 16 ^ g << 16, this.v[i + 1] = g >>> 16 ^ c << 16, this.ADD64AA(this.v, n, i), c = this.v[e] ^ this.v[n], g = this.v[e + 1] ^ this.v[n + 1], this.v[e] = g >>> 31 ^ c << 1, this.v[e + 1] = c >>> 31 ^ g << 1; } blake2bCompress(t, e) { let n = 0; for (n = 0; n < 16; n++)this.v[n] = t.h[n], this.v[n + 16] = this.BLAKE2B_IV32[n]; for (this.v[24] = this.v[24] ^ t.t, this.v[25] = this.v[25] ^ t.t / 4294967296, e && (this.v[28] = ~this.v[28], this.v[29] = ~this.v[29]), n = 0; n < 32; n++)this.m[n] = this.B2B_GET32(t.b, 4 * n); for (n = 0; n < 12; n++)this.B2B_G(0, 8, 16, 24, this.SIGMA82[16 * n + 0], this.SIGMA82[16 * n + 1]), this.B2B_G(2, 10, 18, 26, this.SIGMA82[16 * n + 2], this.SIGMA82[16 * n + 3]), this.B2B_G(4, 12, 20, 28, this.SIGMA82[16 * n + 4], this.SIGMA82[16 * n + 5]), this.B2B_G(6, 14, 22, 30, this.SIGMA82[16 * n + 6], this.SIGMA82[16 * n + 7]), this.B2B_G(0, 10, 20, 30, this.SIGMA82[16 * n + 8], this.SIGMA82[16 * n + 9]), this.B2B_G(2, 12, 22, 24, this.SIGMA82[16 * n + 10], this.SIGMA82[16 * n + 11]), this.B2B_G(4, 14, 16, 26, this.SIGMA82[16 * n + 12], this.SIGMA82[16 * n + 13]), this.B2B_G(6, 8, 18, 28, this.SIGMA82[16 * n + 14], this.SIGMA82[16 * n + 15]); for (n = 0; n < 16; n++)t.h[n] = t.h[n] ^ this.v[n] ^ this.v[n + 16]; } blake2bInit(t, e, n, i) { if (0 === t || t > 64) throw Error("Illegal output length, expected 0 < length <= 64"); if (e && e.length > 64) throw Error("Illegal key, expected Uint8Array with 0 < length <= 64"); if (n && 16 !== n.length) throw Error("Illegal salt, expected Uint8Array with length is 16"); if (i && 16 !== i.length) throw Error("Illegal personal, expected Uint8Array with length is 16"); let r = { b: new Uint8Array(128), h: new Uint32Array(16), t: 0, c: 0, outlen: t }; this.parameterBlock.fill(0), this.parameterBlock[0] = t, e && (this.parameterBlock[1] = e.length), this.parameterBlock[2] = 1, this.parameterBlock[3] = 1, n && this.parameterBlock.set(n, 32), i && this.parameterBlock.set(i, 48); for (let t = 0; t < 16; t++)r.h[t] = this.BLAKE2B_IV32[t] ^ this.B2B_GET32(this.parameterBlock, 4 * t); return e && (this.blake2bUpdate(r, e), r.c = 128), r; } blake2bUpdate(e, n) { for (let t = 0; t < n.length; t++)128 === e.c && (e.t += e.c, this.blake2bCompress(e, !1), e.c = 0), e.b[e.c++] = n[t]; } blake2bFinal(e) { for (e.t += e.c; e.c < 128;)e.b[e.c++] = 0; this.blake2bCompress(e, !0); let n = new Uint8Array(e.outlen); for (let t = 0; t < e.outlen; t++)n[t] = e.h[t >> 2] >> 8 * (3 & t); return n; } blake2bStart(t, e, n, i, r) { n = n || 64, t = this.normalizeInput(t), i && (i = this.normalizeInput(i)), r && (r = this.normalizeInput(r)); let a = this.blake2bInit(n, e, i, r); return this.blake2bUpdate(a, t), this.blake2bFinal(a); } blake2bHex(t, e, n, i, r) { let a = blake2bStart(t, e, n, i, r); return toHex(a); } normalizeInput(e) { let n; if (e instanceof Uint8Array) n = e; else if ("string" == typeof e) { let t = new TextEncoder; n = t.encode(e); } else throw Error("Input must be an string, Buffer or Uint8Array"); return n; } toHex(t) { return Array.prototype.map.call(t, function (t) { return (t < 16 ? "0" : "") + t.toString(16); }).join(""); } static hash(t, e, n = 64, i, r) { let a = new Blake2b, l = a.blake2bStart(t, e, n, i, r); return a.toHex(l); } } const c = {}; let s = null; function LE32(t) { let e = new Uint8Array(4); e[0] = t; e[1] = t >> 8 & 255; e[2] = t >> 16 & 255; e[3] = t >> 24 & 255; return Array.from(e); } function LE64(t) { let e = new Uint8Array(8); e[0] = t; e[1] = t >> 8 & 255; e[2] = t >> 16 & 255; e[3] = t >> 24 & 255; return Array.from(e); } function toHex(t) { return Array.prototype.map.call(t, function (t) { return (t < 16 ? "0" : "") + t.toString(16); }).join(""); } function extract(t, e) { if (e == 0) return Uint8ArrayToBigInt(t.slice(0, 4)); if (e == 1) return Uint8ArrayToBigInt(t.slice(4, 8)); } function NumberToUint8Array(e) { var n = []; let i = Math.ceil(Math.floor(Math.log2(new Number(e)) + 1) / 8); for (let t = 0; t < i; t++) { n.unshift(new Number(e & 255n)); e >>= 8n; } return new Uint8Array(n).reverse(); } function Uint8ArrayToBigInt(e) { let n = 0n; for (let t = e.length - 1; t >= 0; t--) { n = BigInt(e[t]) | n << 8n; } return n; } function ZERO(t) { return new Uint8Array(t); } function Concatenate(...t) { let e = 0; t.forEach(t => { e += t.length; }); const n = new Uint8Array(e); let i = 0; t.forEach(t => { n.set(t, i); i += t.length; }); return n; } function XOR(e, n) { let i = new Uint8Array(1024); for (let t = 0; t < e.length; t++)i[t] = e[t] ^ n[t]; return i; } function MOD(t, e) { return (t % e + e) % e; } function GB(t, e, n, i) { const r = 2n ** 64n - 1n; let a = BigInt(4294967295); t = t + e + BigInt(2) * (t & a) * (e & a) & BigInt.asUintN(64, r); let l = i ^ t; i = l >> BigInt(32) | (l & a) << BigInt(32); n = n + i + BigInt(2) * (n & a) * (i & a) & BigInt.asUintN(64, r); l = e ^ n; e = l >> BigInt(24) | (l & BigInt(16777215)) << BigInt(40); t = t + e + BigInt(2) * (t & a) * (e & a) & BigInt.asUintN(64, r); l = i ^ t; i = l >> BigInt(16) | (l & BigInt(65535)) << BigInt(48); n = n + i + BigInt(2) * (n & a) * (i & a) & BigInt.asUintN(64, r); l = e ^ n; e = l >> BigInt(63) | l << BigInt(1) & BigInt.asUintN(64, r); return [t, e, n, i]; } function P(t, e, n, i, r, a, l, s) { let o; let h = Uint8ArrayToBigInt(t.slice(0, 8)); let c = Uint8ArrayToBigInt(t.slice(8, 16)); let g = Uint8ArrayToBigInt(e.slice(0, 8)); let B = Uint8ArrayToBigInt(e.slice(8, 16)); let A = Uint8ArrayToBigInt(n.slice(0, 8)); let u = Uint8ArrayToBigInt(n.slice(8, 16)); let f = Uint8ArrayToBigInt(i.slice(0, 8)); let b = Uint8ArrayToBigInt(i.slice(8, 16)); let I = Uint8ArrayToBigInt(r.slice(0, 8)); let y = Uint8ArrayToBigInt(r.slice(8, 16)); let U = Uint8ArrayToBigInt(a.slice(0, 8)); let v = Uint8ArrayToBigInt(a.slice(8, 16)); let m = Uint8ArrayToBigInt(l.slice(0, 8)); let k = Uint8ArrayToBigInt(l.slice(8, 16)); let p = Uint8ArrayToBigInt(s.slice(0, 8)); let E = Uint8ArrayToBigInt(s.slice(8, 16)); let w = GB(h, A, I, m); h = w[0]; A = w[1]; I = w[2]; m = w[3]; w = GB(c, u, y, k); c = w[0]; u = w[1]; y = w[2]; k = w[3]; w = GB(g, f, U, p); g = w[0]; f = w[1]; U = w[2]; p = w[3]; w = GB(B, b, v, E); B = w[0]; b = w[1]; v = w[2]; E = w[3]; w = GB(h, u, U, E); h = w[0]; u = w[1]; U = w[2]; E = w[3]; w = GB(c, f, v, m); c = w[0]; f = w[1]; v = w[2]; m = w[3]; w = GB(g, b, I, k); g = w[0]; b = w[1]; I = w[2]; k = w[3]; w = GB(B, A, y, p); B = w[0]; A = w[1]; y = w[2]; p = w[3]; h = NumberToUint8Array(h); c = NumberToUint8Array(c); g = NumberToUint8Array(g); B = NumberToUint8Array(B); A = NumberToUint8Array(A); u = NumberToUint8Array(u); f = NumberToUint8Array(f); b = NumberToUint8Array(b); I = NumberToUint8Array(I); y = NumberToUint8Array(y); U = NumberToUint8Array(U); v = NumberToUint8Array(v); m = NumberToUint8Array(m); k = NumberToUint8Array(k); p = NumberToUint8Array(p); E = NumberToUint8Array(E); if (h.length < 8) { o = 8 - h.length; h = Concatenate(h, ZERO(o)); } if (c.length < 8) { o = 8 - c.length; c = Concatenate(c, ZERO(o)); } if (g.length < 8) { o = 8 - g.length; g = Concatenate(g, ZERO(o)); } if (B.length < 8) { o = 8 - B.length; B = Concatenate(B, ZERO(o)); } if (A.length < 8) { o = 8 - A.length; A = Concatenate(A, ZERO(o)); } if (u.length < 8) { o = 8 - u.length; u = Concatenate(u, ZERO(o)); } if (f.length < 8) { o = 8 - f.length; f = Concatenate(f, ZERO(o)); } if (b.length < 8) { o = 8 - b.length; b = Concatenate(b, ZERO(o)); } if (I.length < 8) { o = 8 - I.length; I = Concatenate(I, ZERO(o)); } if (y.length < 8) { o = 8 - y.length; y = Concatenate(y, ZERO(o)); } if (U.length < 8) { o = 8 - U.length; U = Concatenate(U, ZERO(o)); } if (v.length < 8) { o = 8 - v.length; v = Concatenate(v, ZERO(o)); } if (m.length < 8) { o = 8 - m.length; m = Concatenate(m, ZERO(o)); } if (k.length < 8) { o = 8 - k.length; k = Concatenate(k, ZERO(o)); } if (p.length < 8) { o = 8 - p.length; p = Concatenate(p, ZERO(o)); } if (E.length < 8) { o = 8 - E.length; E = Concatenate(E, ZERO(o)); } t = Concatenate(h, c); e = Concatenate(g, B); n = Concatenate(A, u); i = Concatenate(f, b); r = Concatenate(I, y); a = Concatenate(U, v); l = Concatenate(m, k); s = Concatenate(p, E); return [t, e, n, i, r, a, l, s]; } function G(o, h) { return new Promise(t => { let e = XOR(o, h); let n = []; let i; let r; let a; for (let t = 0; t < 8; t++) { r = 128 * t; i = P(e.slice(r, r + 16), e.slice(r + 16, r + 32), e.slice(r + 32, r + 48), e.slice(r + 48, r + 64), e.slice(r + 64, r + 80), e.slice(r + 80, r + 96), e.slice(r + 96, r + 112), e.slice(r + 112, r + 128)); i.forEach(t => n.push(...t)); } let l = []; for (let t = 0; t < 8; t++) { r = 16 * t; i = P(n.slice(r, r + 16), n.slice(r + 128, r + 128 + 16), n.slice(r + 256, r + 256 + 16), n.slice(r + 384, r + 384 + 16), n.slice(r + 512, r + 512 + 16), n.slice(r + 640, r + 640 + 16), n.slice(r + 768, r + 768 + 16), n.slice(r + 896, r + 896 + 16)); i.forEach(t => n.push(...t)); for (let t = 0; t < i.length; t++)l = Concatenate(l, i[t]); } let s = []; for (let t = 0; t < 8; t++) { r = 16 * t; s = Concatenate(s, l.slice(r, r + 16), l.slice(r + 128, r + 128 + 16), l.slice(r + 256, r + 256 + 16), l.slice(r + 384, r + 384 + 16), l.slice(r + 512, r + 512 + 16), l.slice(r + 640, r + 640 + 16), l.slice(r + 768, r + 768 + 16), l.slice(r + 896, r + 896 + 16)); } t(XOR(s, e)); }); } function blake2bSetup(t, e = null) { s = (new Blake2b).blake2bInit(t, e); } function getHash(t, e, n) { const i = `hash${t}_${e}_${n}`; if (c[i]) { return c[i]; } const r = variableLengthHashFunction(1024, Concatenate(t, LE32(e), LE32(n))); c[i] = r; return r; } function variableLengthHashFunction(t, e) { if (t <= 64) { blake2bSetup(t); i = Concatenate(LE32(t), e); (new Blake2b).blake2bUpdate(s, i); return (new Blake2b).blake2bFinal(s); } else { var n = Math.ceil(t / 32) - 2; var i = Concatenate(LE32(t), e); blake2bSetup(64); (new Blake2b).blake2bUpdate(s, i); var r = (new Blake2b).blake2bFinal(s); var a = r.slice(0, 32); for (let t = 2; t <= n; t++) { blake2bSetup(64); (new Blake2b).blake2bUpdate(s, r); r = (new Blake2b).blake2bFinal(s); a = Concatenate(a, r.slice(0, 32)); } var l = t - 32 * n; blake2bSetup(l); (new Blake2b).blake2bUpdate(s, r); r = (new Blake2b).blake2bFinal(s); return Concatenate(a, r); } } async function getAddressBlock(t, e, n, i, r, a, l) { const s = `${t}_${e}_${n}_${i}_${r}_${a}_${l}`; if (c[s]) { return c[s]; } const o = Concatenate(LE64(t), LE64(e), LE64(n), LE64(i), LE64(r), LE64(a), LE64(l), ZERO(968)); const h = await G(ZERO(1024), await G(ZERO(1024), o)); c[s] = h; return h; } async function _fill_segment(e, n, i, r, t, a, l, s, o, h, c, g) { var B = t == 1 || t == 2 && n == 0 && i <= 1; if (B) { var A = []; var u = 0; while (A.length < a) { u += 1; const E = await getAddressBlock(n, r, i, h, c, t, u); for (let t = 0; t < 1024; t += 8)A.push([Uint8ArrayToBigInt(E.slice(t, t + 4)), Uint8ArrayToBigInt(E.slice(t + 4, t + 8))]); } } for (let t = 0; t < a; t++) { var f = i * a + t; if (n == 0 && f < 2) { e[r][f] = getHash(l, f, r); continue; } var b = NaN; var I = NaN; if (B) { b = A[t][0]; I = A[t][1]; } else { b = extract(e[r][MOD(f - 1, s)], 0); I = extract(e[r][MOD(f - 1, s)], 1); } var y = NaN; if (n == 0 && i == 0) { y = r; } else { y = MOD(I, BigInt(o)); } var U = NaN; if (n == 0) { if (i == 0 || r == y) { U = f - 1; } else if (t == 0) { U = i * a - 1; } else { U = i * a; } } else if (r == y) { U = s - a + t - 1; } else if (t == 0) { U = s - a - 1; } else { U = s - a; } var v = b ** BigInt(2) >> BigInt(32); v = BigInt(U) - BigInt(1) - (BigInt(U) * v >> BigInt(32)); var m = 0; if (n != 0 && i != 3) m = (i + 1) * a; var k = MOD(BigInt(m) + v, BigInt(s)); var p = await G(e[r][MOD(f - 1, s)], e[y][k]); if (n != 0 && g == 19) p = XOR(e[r][f], p); e[r][f] = p; } return e[r].slice(i * a, (i + 1) * a); } onmessage = function (t) { const { type: e, payload: n } = t.data; switch (e) { case "fill-segment": { const { B: i, t: r, segment: a, i: l, y: s, segment_Length: o, H_0: h, q: c, p: g, mm: B, time_cost: A, v: u } = n; _fill_segment(i, r, a, l, s, o, h, c, g, B, A, u).then(t => { postMessage({ type: e, payload: n, result: t }); }); break; } } }; } if (window != self) { runWorker(); }